<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>efrain.fm</title>

  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="favicon.svg">

  <!-- OG / Social preview -->
  <meta property="og:title" content="efrain.fm">
  <meta property="og:description" content="A personal music discovery interface. Ask me for a song.">
  <meta property="og:image" content="https://efrain.fm/og-image.png">
  <meta property="og:url" content="https://efrain.fm">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="efrain.fm">
  <meta name="twitter:description" content="A personal music discovery interface. Ask me for a song.">
  <meta name="twitter:image" content="https://efrain.fm/og-image.png">
  <link rel="stylesheet" href="style.css">
  <!-- Match Safari browser chrome to header/footer color, responsive to dark/light mode -->
  <meta name="theme-color" content="#2C2D2D" media="(prefers-color-scheme: dark)">
  <meta name="theme-color" content="#CECECA" media="(prefers-color-scheme: light)">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
</head>
<body>
  <!-- Background: rings + star field. Canvas covers full viewport. -->
  <canvas id="bg-rings"></canvas>
  <script>
  (function () {

    // ── ring constants (match efrain.fm exactly) ───────────────────────────
    const NUM_RINGS = 9;
    const ANIM_DUR  = 10;
    const BREATHE   = 0.055;
    const OFFSETS   = [0, 0.45, 0.9, 1.35, 1.8, 2.25, 2.7, 3.15, 3.6];

    function ease(t) { return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }
    function ringR(base, offset, now) {
      const t = ((now - offset) % ANIM_DUR + ANIM_DUR) % ANIM_DUR;
      const h = ANIM_DUR / 2;
      const p = t < h ? ease(t/h) : 1 - ease((t-h)/h);
      return base * (1 + BREATHE * p);
    }

    // ── your dialled-in settings ───────────────────────────────────────────
    const STAR_COUNT   = 1450;
    const ROT_MINS     = 18;          // counter-clockwise, one rev per 18 min
    const MAX_SIZE     = 3.25;        // pt, upper ceiling
    const TWINKLE      = 3.0;         // 1–5 scale, medium
    const LARGE_RATIO  = 0.10;        // 10% of stars reach max size
    const EDGE_DECAY   = 6.0;         // very tight concentration near disc edge

    const ROT_SPEED    = (2 * Math.PI) / (ROT_MINS * 60);
    const TWINKLE_BASE = 0.08 + (TWINKLE - 1) * 0.2;

    // ── build fixed star field ─────────────────────────────────────────────
    function buildStar() {
      const u     = Math.random();
      const t     = Math.min(-Math.log(1 - u * (1 - Math.exp(-EDGE_DECAY))) / EDGE_DECAY, 1);
      const normR = 1.02 + t * 3.2;
      const isLarge = Math.random() < LARGE_RATIO;
      const size    = isLarge
        ? 1.5 + Math.random() * (MAX_SIZE - 1.5)
        : 0.8 + Math.random() * 0.7;
      return {
        normR,
        angle:     Math.random() * Math.PI * 2,
        size,
        phase:     Math.random() * Math.PI * 2,
        rot:       Math.random() * Math.PI,
        spikes:    Math.random() < 0.15 ? 6 : 4,
        speedMult: 0.7 + Math.random() * 0.6,
      };
    }
    const stars = Array.from({ length: STAR_COUNT }, buildStar);

    // ── star shape ────────────────────────────────────────────────────────
    function starPath(ctx, x, y, outer, spikes, rot) {
      const inner = outer * 0.28;
      const step  = Math.PI / spikes;
      ctx.beginPath();
      for (let i = 0; i < spikes * 2; i++) {
        const r = i % 2 === 0 ? outer : inner;
        const a = rot + i * step - Math.PI / 2;
        i === 0
          ? ctx.moveTo(x + Math.cos(a)*r, y + Math.sin(a)*r)
          : ctx.lineTo(x + Math.cos(a)*r, y + Math.sin(a)*r);
      }
      ctx.closePath();
    }

    // ── theme detection (respects /theme commands + system pref) ──────────
    function isDarkMode() {
      const theme = document.documentElement.getAttribute('data-theme');
      if (theme === 'dark')  return true;
      if (theme === 'light') return false;
      return window.matchMedia('(prefers-color-scheme: dark)').matches;
    }

    // ── canvas setup ──────────────────────────────────────────────────────
    const canvas = document.getElementById('bg-rings');
    const ctx    = canvas.getContext('2d');
    let dpr      = 1;

    function resize() {
      dpr = window.devicePixelRatio || 1;
      // Canvas must cover the FULL viewport — stars spill behind the card
      canvas.width  = window.innerWidth  * dpr;
      canvas.height = window.innerHeight * dpr;
      canvas.style.width  = window.innerWidth  + 'px';
      canvas.style.height = window.innerHeight + 'px';
    }
    window.addEventListener('resize', resize);
    resize();

    // ── render loop ───────────────────────────────────────────────────────
    const t0 = performance.now();

    function frame() {
      const dark = isDarkMode();
      const now  = (performance.now() - t0) / 1000;
      const W    = window.innerWidth;
      const H    = window.innerHeight;

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, W, H);

      // Background
      const bg = dark ? 'hsl(210,8%,7%)' : 'hsl(36,10%,88%)';
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, W, H);

      // Ring geometry — origin at footer top edge
      const footer    = document.getElementById('input-footer');
      const header    = document.getElementById('header');
      const footerTop = footer ? footer.getBoundingClientRect().top : H;
      const headerBot = header ? header.getBoundingClientRect().bottom : 0;
      const available = footerTop - headerBot;
      const outerBase = available / (1 + BREATHE);
      const step      = outerBase / NUM_RINGS;
      const cx        = W / 2;
      const cy        = footerTop;

      // Animated disc radius (outermost ring)
      const discR = ringR(outerBase, OFFSETS[NUM_RINGS - 1], now);

      // Fill disc solid — the "record" body blocks stars beneath
      ctx.beginPath();
      ctx.arc(cx, cy, discR, 0, Math.PI * 2);
      ctx.fillStyle = bg;
      ctx.fill();

      // Clip star field to outside the disc
      ctx.save();
      ctx.beginPath();
      ctx.rect(-2, -2, W + 4, H + 4);
      ctx.arc(cx, cy, discR, 0, Math.PI * 2, true); // CCW = punch hole
      ctx.clip('evenodd');

      const globalRot = -now * ROT_SPEED;
      // Dark: warm white stars. Light: dark slate stars (same opacity logic)
      // Read star color from CSS — same token system as text, rings, everything else
      const starCol = getComputedStyle(document.documentElement).getPropertyValue('--star-color').trim();

      for (const s of stars) {
        const a  = s.angle + globalRot;
        const r  = s.normR * outerBase;
        const px = cx + Math.cos(a) * r;
        const py = cy + Math.sin(a) * r;

        if (px < -8 || px > W + 8 || py < -8 || py > H + 8) continue;

        const speed = TWINKLE_BASE * s.speedMult;
        const tw    = (now * speed + s.phase) % (Math.PI * 2);
        const raw   = Math.sin(tw);
        // Pure twinkle — sin wave drives opacity, nothing else
        // Color is already correct from --star-color, no brightness multiplier needed
        const alpha = raw > 0.1 ? (raw - 0.1) / 0.9 : 0;
        if (alpha < 0.01) continue;

        ctx.fillStyle = `rgba(${starCol},${alpha.toFixed(3)})`;
        starPath(ctx, px, py, s.size, s.spikes, s.rot + globalRot * 0.15);
        ctx.fill();
      }

      ctx.restore();

      // Ring lines — drawn on top of everything
      ctx.strokeStyle = dark ? 'rgba(245,242,238,0.13)' : 'rgba(14,16,18,0.14)';
      ctx.lineWidth   = 0.75;
      for (let i = 0; i < NUM_RINGS; i++) {
        ctx.beginPath();
        ctx.arc(cx, cy, ringR(step*(i+1), OFFSETS[i], now), 0, Math.PI * 2);
        ctx.stroke();
      }

      requestAnimationFrame(frame);
    }

    frame();

  })();
  </script>

  <div id="app-card">

    <header id="header">
      <h1 id="site-title">
        <span class="logo-efr">efr</span><span class="logo-ai">ai</span><span class="logo-n">n</span><span class="logo-dot">.</span><span class="logo-fm">fm</span>
      </h1>
    </header>

    <div id="chat-container">
      <div id="chat-messages">
        <!-- Messages will appear here -->
      </div>
    </div>

    <footer id="input-footer">
      <div id="input-wrapper">
        <textarea
          id="user-input"
          placeholder="Let's find a groove..."
          rows="1"
        ></textarea>
        <button id="send-button" title="Send message">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="12" y1="19" x2="12" y2="5"></line>
            <polyline points="5 12 12 5 19 12"></polyline>
          </svg>
        </button>
      </div>
    </footer>

  </div>
  <script src="script.js"></script>
</body>
</html>
